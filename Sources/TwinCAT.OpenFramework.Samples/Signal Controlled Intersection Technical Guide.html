<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Signal-Controlled Intersection Automation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f9f9f9;
            color: #333;
            margin: 2rem;
            line-height: 1.6;
        }

        h1, h2, h3 {
            color: #003366;
        }

        pre {
            background: #f0f0f0;
            padding: 1rem;
            overflow-x: auto;
            border-left: 5px solid #007acc;
        }

        .section {
            background-color: #fff;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>

    <h1>Signal-Controlled Intersection Automation – Technical Guide</h1>

    <div class="section">
        <h2>1. Enumeration Definitions</h2>
        <pre>
1.1. SIGNAL_CONTROLLED_INTERSECTION_MODE – defines the general control mode of the intersection.

1.2. SIGNAL_CONTROLLED_INTERSECTION_STATE – defines the current state of the intersection.
     Based on this state, the logic activates appropriate signals on four traffic lights.
     The values ALL_YELLOW, _1_3_YELLOW_AND_2_4_YELLOW, and _2_4_YELLOW_AND_1_3_YELLOW are similar because
     they turn on yellow on all traffic lights, but they carry additional information to determine
     the next state transition.

1.3. TRAFFIC_LIGHT_COLOR – defines the state of a single traffic light.
  </pre>
    </div>

    <div class="section">
        <h2>2. Implement the TrafficLight Device</h2>
        <pre>
The TrafficLight device consists of three standard internal DigitalOutput devices (for red, yellow, and green).
It inherits from the abstract class TOF_Automation.OutputDevice&lt;3&gt;, indicating that it includes 3 internal subdevices.

Inheritance requires implementation of:
- three abstract properties: ClassName, Size, SubDevices
- one abstract method: OnUpdateOutputsFromState

Also implemented: SetLight (custom method).

2.1. ClassName – required by the framework, returns the name of the current class (function block).
     Used for exception reporting.

2.2. Size – used by the framework to manage dynamic memory.

2.3. SubDevices – returns a reference to the array containing actual internal devices
     (digital outputs for turning on the light indicators in this case).

2.4. OnUpdateOutputsFromState – responsible for passing internal virtual device data to terminals or external objects.
     At the traffic light level, this does nothing.
     On the DigitalOutput level, these actions are already implemented in Devices.IO library.

2.5. SetLight – method to control the traffic light by passing a color to activate.
  </pre>
    </div>

    <div class="section">
        <h2>3. Implement the Automation Module: SignalControlledIntersectionAutomationUnit</h2>
        <pre>
This module contains logic for interaction between six devices:
- ON/OFF input
- Mode switch (standard vs blinking yellow)
- Four traffic lights

It inherits from TOF_AutomationEngine.AutomationUnit&lt;6&gt;.

The class must implement:
- ClassName
- Size
- Devices
- StartRequest

Additionally, overrides:
- StopRequest
- OnInitialize
- OnStop

3.1. ClassName – see section 2.1.

3.2. Size – see section 2.2.

3.3. Devices – returns a reference to an array filled with real devices
     (2 digital inputs and 4 traffic light instances).

3.4. StartRequest – signals the engine to enter RUN state.
     Simply returns the value of the ON/OFF switch.

3.5. StopRequest – signals the engine to enter STOPPED state.
     Simply returns the inverted value of the ON/OFF switch.

3.6. OnRun – method called by the engine cyclically while in RUN state.
     Contains core traffic light logic.

3.7. OnInitialize – used during initialization phase.
     Returns TRUE once initialization is complete.
     In our case, it sets timer values in one cycle. In other cases, may take several cycles.

3.8. OnStop – called cyclically in STOPPED state. Turns off all traffic lights.
  </pre>
    </div>

    <div class="section">
        <h2>4. Implement the Automation Runner: SignalControlledIntersectionAutomationRunner</h2>
        <pre>
The runner manages automation modules.
In our case, it controls one instance of SignalControlledIntersectionAutomationUnit.
Inherits from TOF_AutomationEngine.AutomationRunner&lt;1&gt;.

Implements:
- ClassName (see 2.1)
- Size (see 2.2)
- AutomationUnits – returns array of controlled automation units (1 element in our case)
- FB_Init – used to enable simulation mode (since this is a demo project without real terminals)
  </pre>
    </div>

    <div class="section">
        <h2>5. MAIN Program Setup</h2>
        <pre>
In the MAIN program:
- Create instance of SignalControlledIntersectionAutomationRunner
- Call its Run method
  </pre>
    </div>

    <div class="section">
        <h2>Conclusion</h2>
        <pre>
That's all you need.
As you can see, everything is simple – once you understand the framework ideology.
Visualizations are just auxiliary components for demonstration and verification.
  </pre>
    </div>

</body>
</html>
