<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="AutomationController" Id="{715bcab9-6d21-43bf-ac33-fb2affdac1da}" SpecialFunc="None">
    <Declaration><![CDATA[(*

.. <legal notes>

legal notes
=================
| SPDX-FileCopyrightText: © 2025 Oleksandr Tiutyk <trofimich@gmail.com>
| SPDX-License-Identifier: LGPL-3.0-only
| For details check: LGPL-3.0-only_

.. _LGPL-3.0-only: https://www.gnu.org/licenses/lgpl-3.0.en.html

.. </legal notes>

*)

FUNCTION_BLOCK ABSTRACT AutomationController 
VAR_GENERIC CONSTANT
    _DeviceCount : INT(0..1000) := 0;
END_VAR
EXTENDS Core.Object IMPLEMENTS IAutomationController
VAR
	_AutomationRunner : IAutomationRunner;
	
	_PreviousEnabled : BOOL;
	_Enabled : BOOL := TRUE;
	
	_PreviousSimulationMode : BOOL;
		
	_ChildSimulationMode : Automation.CHILD_SIMULATION_MODE;

	_State : Automation.AUTOMATION_CONTROLLER_STATE;	

	_Diagnostics : AUTOMATION_CONTROLLER_DIAGNOSTICS;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Methods to override" Id="{18713aca-9c47-4769-936e-cd3be2ed069c}" />
    <Folder Name="Service memebers" Id="{5df4ad11-a7ac-4049-8c04-41c0497c7559}" />
    <Property Name="ChildSimulationMode" Id="{bef27b77-29d7-4729-ae00-5f308c7e5257}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
{attribute 'OPC.UA.DA' := '1'}
{attribute 'OPC.UA.DA.Access' := '1'}
PROPERTY FINAL ChildSimulationMode : Automation.CHILD_SIMULATION_MODE]]></Declaration>
      <Get Name="Get" Id="{908ef2f4-2445-4cdb-94d6-03aad2842213}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[ChildSimulationMode := _ChildSimulationMode;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="DeviceCount" Id="{612962ce-4a03-4dcb-a1ce-f9e94eefa0eb}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
{attribute 'OPC.UA.DA' := '1'}
{attribute 'OPC.UA.DA.Access' := '1'}
PROPERTY DeviceCount : INT]]></Declaration>
      <Get Name="Get" Id="{cc518b3a-e440-4848-8075-189e5ee4e093}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[DeviceCount := _DeviceCount;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Devices" Id="{f1c94009-408f-4558-836f-c0ffe07e995d}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY ABSTRACT Devices : REFERENCE TO ARRAY [0.._DeviceCount - 1] OF Automation.IDevice]]></Declaration>
      <Get Name="Get" Id="{3053aa14-2407-42d1-bc4d-bd38e5a9f72c}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Diagnostics" Id="{89d80bd2-f2bc-45f4-b861-f9194e4bb6a5}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
{attribute 'OPC.UA.DA' := '1'}
{attribute 'OPC.UA.DA.Access' := '1'}
PROPERTY FINAL Diagnostics : REFERENCE TO AUTOMATION_CONTROLLER_DIAGNOSTICS]]></Declaration>
      <Get Name="Get" Id="{6974a2c5-c336-4c3a-a18a-82f762fc3656}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[Diagnostics REF= _Diagnostics;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="Disable" Id="{e40e66dc-95cc-43e1-8b64-cc2037a8d791}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable':='1'}
METHOD FINAL Disable]]></Declaration>
      <Implementation>
        <ST><![CDATA[_Enabled := FALSE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Enable" Id="{043d7779-c214-4485-a0ee-b5b9085a881c}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable':='1'}
METHOD FINAL Enable]]></Declaration>
      <Implementation>
        <ST><![CDATA[_Enabled := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Enabled" Id="{d5768b1c-6fec-4453-809d-b40c8bd349ff}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
{attribute 'OPC.UA.DA' := '1'}
{attribute 'OPC.UA.DA.Access' := '1'}
PROPERTY FINAL Enabled : BOOL]]></Declaration>
      <Get Name="Get" Id="{a02f7fac-5fa7-4362-9e5d-241f8804e466}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[Enabled := _Enabled;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_init" Id="{46ebd59e-7068-435f-99df-fef2ff312630}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	(* if TRUE, the retain variables are initialized (warm start / cold start)*)
	bInitRetains	: BOOL;
	(* if TRUE, the instance afterwards gets moved into the copy code (online change)*)
	bInCopyCode	: BOOL;
	automationRunner : IAutomationRunner; 
END_VAR
VAR
	automationRunnerNullException : Core.ArgumentNullException;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF automationRunner = 0 THEN
	automationRunnerNullException.Throw(CurrentNamespace.Name, ClassName, __POUNAME(), __POSITION(), 'automationRunner');
END_IF

_AutomationRunner := automationRunner;]]></ST>
      </Implementation>
    </Method>
    <Method Name="fillErrorLog" Id="{13ecfb4e-9729-40c0-b5b7-a5c89543cb1f}" FolderPath="Service memebers\">
      <Declaration><![CDATA[METHOD PRIVATE fillErrorLog
VAR_IN_OUT
	targetErrorLog : AUTOMATION_ERROR_LOG;
	sourceException : IException;  
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[targetErrorLog.ShortMessage := sourceException.GetMessage(FALSE, FALSE);
targetErrorLog.FullMessage := sourceException.GetMessage(TRUE, TRUE);
targetErrorLog.Source := sourceException.GetSourceDescription();
targetErrorLog.LocalTimestamp := sourceException.LocalTimestamp;
targetErrorLog.UtcTimestamp := sourceException.UtcTimestamp;

Core.LogManager.TryLogException(sourceException, "AutomationControllerError");]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnEnabledChanged" Id="{a0fb7939-155f-40af-89fe-97ebfa840d0f}" FolderPath="Methods to override\">
      <Declaration><![CDATA[METHOD PROTECTED OnEnabledChanged
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnFault" Id="{47b787a0-74db-428e-a805-17453cf9f9ee}" FolderPath="Methods to override\">
      <Declaration><![CDATA[METHOD PROTECTED OnFault
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnInitialize" Id="{f30a4c4a-7966-446f-95b6-a1ce70efb536}" FolderPath="Methods to override\">
      <Declaration><![CDATA[METHOD PROTECTED OnInitialize : BOOL
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[OnInitialize := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnRun" Id="{f7f57440-8e03-4827-9c8c-4741292bf658}" FolderPath="Methods to override\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT OnRun
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnSimulationModeChanged" Id="{8009bfda-12ee-4bc1-acc8-cef23fa11dd6}" FolderPath="Methods to override\">
      <Declaration><![CDATA[METHOD PROTECTED OnSimulationModeChanged
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnStop" Id="{e9a7087e-9b95-447b-8bf1-2d25488d5f40}" FolderPath="Methods to override\">
      <Declaration><![CDATA[METHOD PROTECTED OnStop
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Property Name="Parent" Id="{cd112a76-f83d-488d-84c6-d08f9cecfc8a}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY FINAL Parent : ISimulatable]]></Declaration>
      <Get Name="Get" Id="{071c96e9-2c52-4b03-916f-c2b1192dc418}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[Parent := _AutomationRunner;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="processAutomationRunnerFaultState" Id="{bf8dc720-7294-48a4-b0de-8d1fd4d46c48}" FolderPath="Service memebers\">
      <Declaration><![CDATA[METHOD PRIVATE processAutomationRunnerFaultState
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
	aggregateException : Core.AggregateException;
END_VAR
VAR
	i : DINT;

	exceptionCode : __SYSTEM.ExceptionCode;
	exception : IException;
	
	inputDevice : Automation.IInputDevice;
	outputDevice : Automation.IOutputDevice;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT Enabled THEN
	RETURN;
END_IF

IF _State = Automation.AUTOMATION_CONTROLLER_STATE.RUNNING THEN
	_State := Automation.AUTOMATION_CONTROLLER_STATE.STOPPING;
END_IF

// handle input devices
IF __ISVALIDREF(Devices) AND_THEN _DeviceCount > 0 THEN
	FOR i := 0 TO _DeviceCount - 1 DO
		IF NOT __QUERYINTERFACE(Devices[i], inputDevice) OR_ELSE NOT inputDevice.Enabled THEN
			CONTINUE;
		END_IF
		
		__TRY
			inputDevice.UpdateStateFromInputs(executionContext, aggregateException);
		__CATCH(exceptionCode)
			exception := ExceptionManager.GetLastException(exceptionCode);

			fillErrorLog(Diagnostics.LastRefreshInputDeviceNonFatalError, exception);
					
			aggregateException.AddInnerException(exception);
		__ENDTRY
	END_FOR
END_IF

// handle fault
__TRY
	IF _State = Automation.AUTOMATION_CONTROLLER_STATE.FAULT THEN
		OnFault(executionContext);
	ELSE
		OnStop(executionContext);
	END_IF
__CATCH(exceptionCode)	
	exception := ExceptionManager.GetLastException(exceptionCode);	

	fillErrorLog(Diagnostics.LastFaultError, exception);					

	aggregateException.AddInnerException(exception);
__ENDTRY

// handle output devices
IF __ISVALIDREF(Devices) AND_THEN _DeviceCount > 0 THEN
	FOR i := 0 TO _DeviceCount - 1 DO
		IF NOT __QUERYINTERFACE(Devices[i], outputDevice) OR_ELSE NOT outputDevice.Enabled THEN
			CONTINUE;
		END_IF
		
		__TRY
			outputDevice.UpdateOutputsFromState(executionContext, aggregateException); 
		__CATCH(exceptionCode)
			exception := ExceptionManager.GetLastException(exceptionCode);
			
			fillErrorLog(Diagnostics.LastRefreshOutputDeviceNonFatalError, exception);
					
			aggregateException.AddInnerException(exception);
		__ENDTRY 
	END_FOR
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="processAutomationRunnerInitializingState" Id="{77df98d2-5a5f-4aa7-9f80-f54434f2c5ba}" FolderPath="Service memebers\">
      <Declaration><![CDATA[METHOD PRIVATE processAutomationRunnerInitializingState
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
END_VAR
VAR
	initialized : BOOL;
	
	i : DINT;

	exceptionCode : __SYSTEM.ExceptionCode;
	exception : IException;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _State <> Automation.AUTOMATION_CONTROLLER_STATE.INITIALIZING THEN
	RETURN;
END_IF

initialized := TRUE;

__TRY
	IF __ISVALIDREF(Devices) THEN
		FOR i := 0 TO _DeviceCount - 1 DO
			initialized := initialized AND Devices[i].Initialize(executionContext);
		END_FOR
	END_IF
	
	initialized := initialized AND OnInitialize(executionContext);
	
	IF initialized THEN
		_State := AUTOMATION_CONTROLLER_STATE.RUNNING;
	END_IF	
__CATCH(exceptionCode)
	_State := AUTOMATION_CONTROLLER_STATE.FAULT;
	
	exception := ExceptionManager.GetLastException(exceptionCode);
					
	fillErrorLog(Diagnostics.InitializationError, exception);					

	ExceptionManager.ReThrowLastException();
__ENDTRY]]></ST>
      </Implementation>
    </Method>
    <Method Name="processAutomationRunnerRunningState" Id="{bb18fb5a-a25a-4107-9c1d-6788c20e09ff}" FolderPath="Service memebers\">
      <Declaration><![CDATA[METHOD PRIVATE processAutomationRunnerRunningState
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
	aggregateException : Core.AggregateException;
END_VAR
VAR
	i : DINT;

	exceptionCode : __SYSTEM.ExceptionCode;
	exception : IException;
		
	invalidStateException : Core.StandardException;
	
	inputDevice : Automation.IInputDevice;
	outputDevice : Automation.IOutputDevice;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _State = Automation.AUTOMATION_CONTROLLER_STATE.INITIALIZING THEN
	invalidStateException.Throw(CurrentNamespace.Name, ClassName, __POUNAME(), __POSITION(), "Automation controller is not initialized");
END_IF

IF NOT Enabled THEN
	RETURN;
END_IF

IF _State = Automation.AUTOMATION_CONTROLLER_STATE.FAULT THEN
	invalidStateException.Throw(CurrentNamespace.Name, ClassName, __POUNAME(), __POSITION(), "Automation controller is in fault state");
END_IF

// handle input devices
IF __ISVALIDREF(Devices) AND_THEN _DeviceCount > 0 THEN
	FOR i := 0 TO _DeviceCount - 1 DO
		IF NOT __QUERYINTERFACE(Devices[i], inputDevice) OR_ELSE NOT inputDevice.Enabled THEN
			CONTINUE;
		END_IF
		
		__TRY
			inputDevice.UpdateStateFromInputs(executionContext, aggregateException);
		__CATCH(exceptionCode)
			exception := ExceptionManager.GetLastException(exceptionCode);
						
			IF NOT exception.Fatal THEN
				fillErrorLog(Diagnostics.LastRefreshInputDeviceNonFatalError, exception);					
				aggregateException.AddInnerException(exception);
			ELSE
				_State := AUTOMATION_CONTROLLER_STATE.FAULT;
				fillErrorLog(Diagnostics.FatalError, exception);				
				ExceptionManager.ReThrowLastException();
			END_IF		
		__ENDTRY
	END_FOR
END_IF

// handle running and stopping
__TRY
	IF _State = Automation.AUTOMATION_CONTROLLER_STATE.RUNNING AND_THEN StopRequest THEN
		_State := Automation.AUTOMATION_CONTROLLER_STATE.STOPPING;
	ELSIF _State = Automation.AUTOMATION_CONTROLLER_STATE.STOPPING AND_THEN StartRequest AND_THEN NOT StopRequest THEN
		_State := Automation.AUTOMATION_CONTROLLER_STATE.RUNNING;
	END_IF

	IF _State = Automation.AUTOMATION_CONTROLLER_STATE.RUNNING THEN
		OnRun(executionContext);
	ELSE
		OnStop(executionContext);
	END_IF
__CATCH(exceptionCode)	
	exception := ExceptionManager.GetLastException(exceptionCode);	

	IF NOT exception.Fatal THEN		
		IF _State = Automation.AUTOMATION_CONTROLLER_STATE.RUNNING THEN
			fillErrorLog(Diagnostics.LastRunningNonFatalError, exception);					
		ELSE
			fillErrorLog(Diagnostics.LastStoppingNonFatalError, exception);					
		END_IF

		aggregateException.AddInnerException(exception);
	ELSE
		_State := AUTOMATION_CONTROLLER_STATE.FAULT;
		fillErrorLog(Diagnostics.FatalError, exception);					
		ExceptionManager.ReThrowLastException();
	END_IF	
__ENDTRY

// handle output devices
IF __ISVALIDREF(Devices) AND_THEN _DeviceCount > 0 THEN
	FOR i := 0 TO _DeviceCount - 1 DO
		IF NOT __QUERYINTERFACE(Devices[i], outputDevice) OR_ELSE NOT outputDevice.Enabled THEN
			CONTINUE;
		END_IF
		
		__TRY
			outputDevice.UpdateOutputsFromState(executionContext, aggregateException); 
		__CATCH(exceptionCode)
			exception := ExceptionManager.GetLastException(exceptionCode);
						
			IF NOT exception.Fatal THEN
				fillErrorLog(Diagnostics.LastRefreshOutputDeviceNonFatalError, exception);					
				aggregateException.AddInnerException(exception);
			ELSE
				_State := AUTOMATION_CONTROLLER_STATE.FAULT;
				fillErrorLog(Diagnostics.FatalError, exception);					
				ExceptionManager.ReThrowLastException();
			END_IF		
		__ENDTRY 
	END_FOR
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="processEnabledState" Id="{0c7660a7-6c76-4840-a79a-51fddbd7b920}" FolderPath="Service memebers\">
      <Declaration><![CDATA[METHOD PRIVATE processEnabledState
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
	aggregateException : Core.AggregateException;	
END_VAR
VAR
	i : DINT;

	exceptionCode : __SYSTEM.ExceptionCode;
	exception : IException;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _PreviousEnabled <> _Enabled THEN
	__TRY	
		OnEnabledChanged(executionContext);
		
		_PreviousEnabled := _Enabled;		
	__CATCH(exceptionCode)
		_PreviousEnabled := _Enabled;
		
		exception := ExceptionManager.GetLastException(exceptionCode);
					
		IF NOT exception.Fatal THEN
			fillErrorLog(Diagnostics.LastEnableStateChangingNonFatalError, exception);					
			aggregateException.AddInnerException(exception);
		ELSE
			_State := AUTOMATION_CONTROLLER_STATE.FAULT;
			fillErrorLog(Diagnostics.FatalError, exception);				
			ExceptionManager.ReThrowLastException();
		END_IF		
	__ENDTRY
END_IF

IF __ISVALIDREF(Devices) AND_THEN _DeviceCount > 0 THEN
	FOR i := 0 TO _DeviceCount - 1 DO
		__TRY
			Devices[i].HandleEnabledState(executionContext, aggregateException);
		__CATCH(exceptionCode)
			exception := ExceptionManager.GetLastException(exceptionCode);
						
			IF NOT exception.Fatal THEN
				fillErrorLog(Diagnostics.LastEnableStateChangingNonFatalError, exception);					
				aggregateException.AddInnerException(exception);
			ELSE
				_State := AUTOMATION_CONTROLLER_STATE.FAULT;
				fillErrorLog(Diagnostics.FatalError, exception);				
				ExceptionManager.ReThrowLastException();
			END_IF		
		__ENDTRY
	END_FOR	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="processSimulationModeState" Id="{42fe74dc-ad60-417f-a1ae-048a20e31260}" FolderPath="Service memebers\">
      <Declaration><![CDATA[METHOD PRIVATE processSimulationModeState
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
	aggregateException : Core.AggregateException;
END_VAR
VAR
	i : DINT;

	exceptionCode : __SYSTEM.ExceptionCode;
	exception : IException;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF _PreviousSimulationMode <> SimulationMode THEN
	__TRY	
		OnSimulationModeChanged(executionContext);
		
		_PreviousSimulationMode := _Enabled;		
	__CATCH(exceptionCode)
		_PreviousSimulationMode := _Enabled;
		
		exception := ExceptionManager.GetLastException(exceptionCode);
					
		IF NOT exception.Fatal THEN
			fillErrorLog(Diagnostics.LastSimulationModeChangingNonFatalError, exception);					
			aggregateException.AddInnerException(exception);
		ELSE
			_State := AUTOMATION_CONTROLLER_STATE.FAULT;
			fillErrorLog(Diagnostics.FatalError, exception);				
			ExceptionManager.ReThrowLastException();
		END_IF		
	__ENDTRY
END_IF

IF __ISVALIDREF(Devices) AND_THEN _DeviceCount > 0 THEN
	FOR i := 0 TO _DeviceCount - 1 DO
		__TRY
			Devices[i].HandleEnabledState(executionContext, aggregateException);
		__CATCH(exceptionCode)
			exception := ExceptionManager.GetLastException(exceptionCode);
						
			IF NOT exception.Fatal THEN
				fillErrorLog(Diagnostics.LastSimulationModeChangingNonFatalError, exception);					
				aggregateException.AddInnerException(exception);
			ELSE
				_State := AUTOMATION_CONTROLLER_STATE.FAULT;
				fillErrorLog(Diagnostics.FatalError, exception);				
				ExceptionManager.ReThrowLastException();
			END_IF		
		__ENDTRY
	END_FOR	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Run" Id="{edf960fe-6c94-4ace-a7be-524e71aafd2a}">
      <Declaration><![CDATA[METHOD FINAL Run
VAR_IN_OUT CONSTANT
	executionContext : AUTOMATION_EXECUTION_CONTEXT;
END_VAR
VAR
	aggregateException : Core.AggregateException;	

	exceptionCode : __SYSTEM.ExceptionCode;
	exception : IException;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[processEnabledState(executionContext, aggregateException);

processSimulationModeState(executionContext, aggregateException);

CASE executionContext.AutomationRunnerState OF
	Automation.AUTOMATION_RUNNER_STATE.INITIALIZING:
		processAutomationRunnerInitializingState(executionContext);
	
	Automation.AUTOMATION_RUNNER_STATE.RUNNING:
		processAutomationRunnerRunningState(executionContext, aggregateException);
	
	Automation.AUTOMATION_RUNNER_STATE.FAULT:
		processAutomationRunnerFaultState(executionContext, aggregateException);
END_CASE

IF NOT aggregateException.Empty THEN
	aggregateException.Throw(CurrentNamespace.Name, ClassName, __POUNAME(), __POSITION());
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="SimulationMode" Id="{d06903e4-ea01-42fc-a468-b432f4fc159b}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
{attribute 'OPC.UA.DA' := '1'}
{attribute 'OPC.UA.DA.Access' := '1'}
PROPERTY FINAL SimulationMode : BOOL]]></Declaration>
      <Get Name="Get" Id="{c0b7b53d-f5eb-4914-b43e-57840bfbc5da}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[CASE _ChildSimulationMode OF
	CHILD_SIMULATION_MODE.INHERITED:
		SimulationMode := _AutomationRunner.SimulationMode;
 	
	CHILD_SIMULATION_MODE.ON:
		SimulationMode := TRUE;
	
	CHILD_SIMULATION_MODE.OFF:
		SimulationMode := FALSE;
END_CASE]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="StartRequest" Id="{efbb592d-bbef-421a-a357-ab7d8e20bcce}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY ABSTRACT StartRequest : BOOL]]></Declaration>
      <Get Name="Get" Id="{f92effac-0e0d-4aa7-89d3-b6db7e0aeded}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="State" Id="{b57e32a3-ebf4-4492-89c3-02193601134f}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
{attribute 'OPC.UA.DA' := '1'}
{attribute 'OPC.UA.DA.Access' := '1'}
PROPERTY FINAL State : Automation.AUTOMATION_CONTROLLER_STATE]]></Declaration>
      <Get Name="Get" Id="{e675c2b5-5934-4e03-a0b0-61bb8b8e344b}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[State := _State;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="StopRequest" Id="{608fa160-a1ee-4b42-a40b-f54246a9eaa1}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY StopRequest : BOOL]]></Declaration>
      <Get Name="Get" Id="{ea1fec94-0a94-4c91-97a8-b829d143d2d9}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="TryGetDeviceByIndex" Id="{822b2535-548b-4af3-814e-271dc3e4c03f}">
      <Declaration><![CDATA[METHOD FINAL TryGetDeviceByIndex : Automation.IDevice
VAR_INPUT
	index : BYTE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF index < 0 OR_ELSE index >= _DeviceCount OR_ELSE NOT __ISVALIDREF(Devices) THEN
	RETURN;
END_IF

TryGetDeviceByIndex := Devices[index];]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrySetChildSimulationMode" Id="{ce482073-27fa-43fd-9312-3aa51f8a272a}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable':='1'}
METHOD TrySetChildSimulationMode : BOOL
VAR_INPUT
	value : CHILD_SIMULATION_MODE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_ChildSimulationMode := value;

TrySetChildSimulationMode := TRUE;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>